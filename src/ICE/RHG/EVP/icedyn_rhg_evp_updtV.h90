            !$acc parallel loop collapse(2) present( vtau_ice, av_i, V_oce, ff_v, zmV_dt )
            DO jj=Njs0, Nje0
               DO ji=Nis0, Nie0
                  !
                  zmask = REAL(kmsk01y(ji,jj),wp)
                  zA    = av_i(ji,jj)
                  zVi   = v_ice(ji,jj)   ! V ice @ v-points!
                  zUi   = uVice(ji,jj)   ! U ice @ v-points!
                  zVo   = V_oce(ji,jj,2) ! V oce @ v-points
                  zUo   = V_oce(ji,jj,3) ! U oce @ v-points
                  zM_dt = zmV_dt(ji,jj)  ! M/dt
                  !
                  ztau_ai = 0.5_wp*( vtau_ice(ji,jj) + vtau_ice(ji,jj+1) ) * (2._wp-vmask(ji,jj,1))*MAX(xmskt(ji,jj),xmskt(ji,jj+1))
                  ztau_ai = zA * ztau_ai
                  !
                  !                 !--- tau_io/(v_oce - v_ice)
                  zt1 = zVi - zVo
                  zt2 = zUi - zUo
                  zTauO = zA * zrhoco * SQRT( zt1*zt1 + zt2*zt2 )
                  !
                  !                 !--- Ocean-to-Ice stress
                  ztauy_oi = zTauO * ( zVo - zVi )
                  !
                  !                 !--- Coriolis at V-points
                  zcorio = -ff_v(ji,jj) * zUi
                  !
                  !                 !--- Sum of external forces (explicit solution) = F + tau_ia + Coriolis + spg + tau_io
                  zRHS = zfV(ji,jj) + ztau_ai + ridlzd*(zcorio + zspgV(ji,jj)) + ztauy_oi
                  !
                  !--- ice velocity using aEVP (Kimmritz et al 2016 & 2017)
                  zbetav = MAX( zbeta(ji,jj), zbeta(ji,jj+1) )
                  v_ice(ji,jj) = ( ( ( zM_dt * ( zbetav * zVi + v_ice_b(ji,jj) )         & ! previous velocity
                     &                      + zRHS + zTauO * zVi )                       & ! F + tau_ia + Coriolis + spg + tau_io(only ocean part)
                     &               / MAX( epsi20, zM_dt * ( zbetav + 1._wp ) + zTauO ) & ! m/dt + tau_io(only ice part) + landfast
                     &             ) * zmask + zVo * 0.01_wp * (1._wp - zmask)           & ! v_ice = v_oce/100 if mass < rmass_min & conc < rconc_min
                     &           ) * REAL(kmsk00y(ji,jj),wp)
                  !
               END DO
            END DO
            !$acc end parallel loop

# if defined _OPENACC
            IF( l_Iperio ) CALL lbc_lnk_EW_gpu( 'icedyn_rhg_bbm', v_ice )
            IF( l_Jperio ) CALL lbc_lnk_NS_gpu( 'icedyn_rhg_bbm', v_ice )
# else
            CALL lbc_lnk( 'icedyn_rhg_evp', v_ice,'V',-1._wp )
# endif

            ! Since we have just updated `v_ice` it is now time to update `vUice`:
            !      energy conserving formulation:
            !$acc parallel loop collapse(2)
            DO jj=Njs0-nn_hls+1, Nje0+nn_hls
               DO ji=Nis0-nn_hls, Nie0+nn_hls-1
                  vUice(ji,jj) = 0.25_wp * r1_e1u(ji,jj) * umask(ji,jj,1) &
                     &           * ( e1v(ji,jj)*v_ice(ji,jj) + e1v(ji,jj-1)*v_ice(ji,jj-1) + e1v(ji+1,jj)*v_ice(ji+1,jj) + e1v(ji+1,jj-1)*v_ice(ji+1,jj-1) )
               END DO
            END DO
            !$acc end parallel loop

            !LOLOfixme lbc_lnk ? Probably of for now with `nn_hls=3` !
